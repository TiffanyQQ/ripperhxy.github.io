---
layout: post
title: JVM参数调优配置&垃圾回收机制
date: 2019-01-05
tags: All About Java
---

## java内存结构

![1546846363666](/images/blog/jvm/dui.png)



### 方法区

方法区可以理解为永久区，static关键修饰、常量信息当class文件被加载的时候，就会初始化。所有线程会被共享。注意：线程安全问题

### 调优问题

web开发，定义常量太多不好，因为方法区不会被垃圾回收机制回收，占用很多内存。

### 堆

堆内存用于存放由new创建的对象和数组，调优策略是对堆调优，堆所有线程会被共享。

![1546846570900](/images/blog/jvm/fendai.png)

刚创建出来的对象，会存放在eden区

新生代：刚创建的对象，先存放在新生代

老年代：如果对象在频繁的使用，对象放入到老年代。

垃圾回收机制主要回收新生代。

调优：在web系统中，尽量减少常量信息，尽量减少垃圾回收机制次数。新生代回收次数比老年多。

参数配置：

-XX:+PrintGC      每次触发GC的时候打印相关日志

-XX:+UseSerialGC      串行回收

-XX:+PrintGCDetails  更详细的GC日志

-Xms               堆初始值

-Xmx               堆最大可用值

-Xmn               新生代堆最大可用值----新生代大小，一般设为整个堆的1/3到1/4左右

-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例

-XX:NewRatio=2         设置新生代和老年代的比例

### 栈

定义基本局部变量，栈代码运行完毕，自动释放内存。每个线程私有，互不共享，栈不会产生线程安全问题。

## 内存溢出解决办法

### 堆内存溢出

设置堆内存大小 -Xms1m –Xmx10m -XX:+HeapDumpOnOutOfMemoryError

### 栈内存溢出

栈溢出是由于产生递归调用，循环遍历是不会的，但是循环方法里面产生递归调用，也会发生栈溢出

```java
public class JvmDemo04 {
	 private static int count;
	 public static void count(){
		try {
			 count++;
			 count();
		} catch (Throwable e) {
			System.out.println("最大深度:"+count);
			e.printStackTrace();
		}
	 }
	 public static void main(String[] args) {
		 count();
	}
}

```

解决办法：设置线程最大调用深度	-Xss5m 设置最大调用深度

## jvm参数调优

1、堆初始值与堆内存最大值一定要保持一致，减少垃圾回收次数，初始值越小，垃圾回收次数越多。

2、设置新生代与老年代回收比例：新生代与老年代1/3或者1/4

## 垃圾回收机制算法分析

### 垃圾回收机制

垃圾回收机制不定时，向堆内存清理不可达对象。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

### 垃圾回收简要过程

不可达的对象并不会马上就会被直接回收，而是至少要经过两次标记的过程。第一次被标记过的对象，会检查该对象是否重写了finalize()方法。如果重写了该方法，则将其放入一个F-Query队列中，否则，直接将对象加入“即将回收”集合。在第二次标记之前，F-Query队列中的所有对象会逐个执行finalize()方法，但是不保证该队列中所有对象的finalize()方法都能被执行，这是因为JVM创建一个低优先级的线程去运行此队列中的方法，很可能在没有遍历完之前，就已经被剥夺了运行的权利。

### finalize作用

Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的

### 内存溢出和内存泄露的区别

内存溢出：实际内存超出了指定内存

内存泄露：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着

防止内存泄露：

1、特别注意一些像HashMap、ArrayList的集合对象，它们经常会引发内存泄漏。当它们被声明为static时，它们的生命周期就会和应用程序一样长。

2、特别注意事件监听和回调函数。当一个监听器在使用的时候被注册，但不再使用之后却未被反注册。

3、“如果一个类自己管理内存，那开发人员就得小心内存泄漏问题了。”通常一些成员变量引用其他对象，初始化的时候需要置空。

### 垃圾回收机制算法

#### 引用计数法

引用计数，每个对象都会有一个标记，默认是15次，gc回收时，对象现在如果是不可达就减去1，如果可以就加上1。

引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

#### 复制算法（s0，s1）

复制算法用于在新生代垃圾回收

原理：S0和s1将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

复制算法的缺点显而易见，可使用的内存降为原来一半。

#### 标记清除算法

标记清除算法为每个对象做一个标记，0可达，1不可达。对象没有经常使用，将对象变为1（不可达）。

标记指示回收，那就直接收掉；标记指示对象还能用，那就原地不动留下。

缺点：

1. 标记与清除没有连续性效率低;

2. 清除之后内存会产生大量碎片；

#### 标记压缩算法（老年代）

标记压缩法在标记清除基础之上做了优化，把存活的对象压缩到内存一端,而后进行垃圾清理。(java中老年代使用的就是标记压缩法)，连续性，没有碎片。

#### 分代收集算法

根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和老年代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。

对于新生代和老年代来说,新生代回收频率很高,但是每次回收耗时很短,而老年代回收频率较低,但是耗时会相对较长,所以应该尽量减少老年代的GC.

### 垃圾回收时产生停顿

停顿的目的是为了终止所有的应用线程，只有这样的系统才不会有新垃圾的产生

### 串行回收器和并行回收器

串行回收器是利用单线程进行回收，效率低

并行回收器是利用多线程进行回收，效率高
